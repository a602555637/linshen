# 设计模式

## 创建型模式

### 单例模式

Singleton Pattern -- 游戏的存档  
保证**一个类只有一个实例**，并提供一个访问它的**全局访问点**，也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。

单例模式主要解决的问题就是**节约资源，保持访问一致性**。

- 优点：

1. 单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接;
2. 单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作;
3. 只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少;

- 缺点：

1. 单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口;
2. 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

- 使用场景：

1. 当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；
2. 当项目中需要一个公共的状态，那么需要使用单例模式来**保证访问一致性**。

### 工厂模式

Factory Pattern -- 去小餐馆下馆子  
根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是**将对象的创建与对象的实现分离**。

- 工厂模式将**对象的创建和实现分离**

- 优点：

1. 良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下;
2. 扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则;
3. 解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流;

- 缺点：带来了额外的系统复杂度，增加了抽象性;

- 使用场景：
  对象的创建比较复杂，而访问者无需知道创建的具体流程；
  处理大量具有相同属性的小对象。

### 抽象工厂模式

### 建造者模式

## 结构型模式

## 行为型模式

## 其它模式
