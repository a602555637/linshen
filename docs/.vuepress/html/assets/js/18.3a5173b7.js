(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{364:function(t,v,_){"use strict";_.r(v);var a=_(42),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),_("h2",{attrs:{id:"创建型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[t._v("#")]),t._v(" 创建型模式")]),t._v(" "),_("h3",{attrs:{id:"单例模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[t._v("#")]),t._v(" 单例模式")]),t._v(" "),_("p",[t._v("Singleton Pattern -- 游戏的存档"),_("br"),t._v("\n保证"),_("strong",[t._v("一个类只有一个实例")]),t._v("，并提供一个访问它的"),_("strong",[t._v("全局访问点")]),t._v("，也就是说，第二次使用同一个类创建新对象的时候，应该得到与第一次创建的对象完全相同的对象。")]),t._v(" "),_("p",[t._v("单例模式主要解决的问题就是"),_("strong",[t._v("节约资源，保持访问一致性")]),t._v("。")]),t._v(" "),_("ul",[_("li",[t._v("优点：")])]),t._v(" "),_("ol",[_("li",[t._v("单例模式在创建后在内存中只存在一个实例，节约了内存开支和实例化时的性能开支，特别是需要重复使用一个创建开销比较大的类时，比起实例不断地销毁和重新实例化，单例能节约更多资源，比如数据库连接;")]),t._v(" "),_("li",[t._v("单例模式可以解决对资源的多重占用，比如写文件操作时，因为只有一个实例，可以避免对一个文件进行同时操作;")]),t._v(" "),_("li",[t._v("只使用一个实例，也可以减小垃圾回收机制 GC（Garbage Collecation） 的压力，表现在浏览器中就是系统卡顿减少，操作更流畅，CPU 资源占用更少;")])]),t._v(" "),_("ul",[_("li",[t._v("缺点：")])]),t._v(" "),_("ol",[_("li",[t._v("单例模式对扩展不友好，一般不容易扩展，因为单例模式一般自行实例化，没有接口;")]),t._v(" "),_("li",[t._v("与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。")])]),t._v(" "),_("ul",[_("li",[t._v("使用场景：")])]),t._v(" "),_("ol",[_("li",[t._v("当一个类的实例化过程消耗的资源过多，可以使用单例模式来避免性能浪费；")]),t._v(" "),_("li",[t._v("当项目中需要一个公共的状态，那么需要使用单例模式来"),_("strong",[t._v("保证访问一致性")]),t._v("。")])]),t._v(" "),_("h3",{attrs:{id:"工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[t._v("#")]),t._v(" 工厂模式")]),t._v(" "),_("p",[t._v("Factory Pattern -- 去小餐馆下馆子"),_("br"),t._v("\n根据不同的输入返回不同类的实例，一般用来创建同一类对象。工厂方式的主要思想是"),_("strong",[t._v("将对象的创建与对象的实现分离")]),t._v("。")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("工厂模式将"),_("strong",[t._v("对象的创建和实现分离")])])]),t._v(" "),_("li",[_("p",[t._v("优点：")])])]),t._v(" "),_("ol",[_("li",[t._v("良好的封装，代码结构清晰，访问者无需知道对象的创建流程，特别是创建比较复杂的情况下;")]),t._v(" "),_("li",[t._v("扩展性优良，通过工厂方法隔离了用户和创建流程隔离，符合开放封闭原则;")]),t._v(" "),_("li",[t._v("解耦了高层逻辑和底层产品类，符合最少知识原则，不需要的就不要去交流;")])]),t._v(" "),_("ul",[_("li",[_("p",[t._v("缺点：带来了额外的系统复杂度，增加了抽象性;")])]),t._v(" "),_("li",[_("p",[t._v("使用场景：\n对象的创建比较复杂，而访问者无需知道创建的具体流程；\n处理大量具有相同属性的小对象。")])])]),t._v(" "),_("h3",{attrs:{id:"抽象工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[t._v("#")]),t._v(" 抽象工厂模式")]),t._v(" "),_("h3",{attrs:{id:"建造者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#建造者模式"}},[t._v("#")]),t._v(" 建造者模式")]),t._v(" "),_("h2",{attrs:{id:"结构型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[t._v("#")]),t._v(" 结构型模式")]),t._v(" "),_("h2",{attrs:{id:"行为型模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行为型模式"}},[t._v("#")]),t._v(" 行为型模式")]),t._v(" "),_("h2",{attrs:{id:"其它模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#其它模式"}},[t._v("#")]),t._v(" 其它模式")])])}),[],!1,null,null,null);v.default=r.exports}}]);